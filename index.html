<!DOCTYPE html>
<html>
  <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
        <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js@3.4.5/aframe/build/aframe-ar.min.js"></script>
        <!--<script> window.THREE = AFRAME.THREE; </script>
        <script src="https://unpkg.com/three@0.173.0/examples/js/loaders/RGBELoader.js"></script>
        <script src="https://unpkg.com/three@0.173.0/examples/js/loaders/EXRLoader.js"></script>-->
        <style>
            .overlay {
                position: absolute;
                top: 10px;
                left: 10px;
                z-index: 1;
                padding: 10px;
                border-radius: 5px;
            }
            label {
                margin-right: 10px;
                font-weight: bold;
            }
            input[type=range] {
                width: 100px;
            }
            #menu {
                background: rgba(255, 255, 255, 1);
                padding: 10px;
                border-radius: 5px;
                width:100px;
                text-align: center;
                font-family: Arial, sans-serif;
                font-size: 14px;
                color: #333;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            }
        </style>
  </head>
  <body style="margin:0; overflow:hidden">
        <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;" hdri-env="src: url(./Assets/overcast_soil_puresky_4k.exr)" renderer="alpha: true; toneMapping: ACESFilmic; exposure: 1.0" webxr="optionalFeatures: dom-overlay; overlayElement: #ui" xr-mode-ui="enabled: true">
            <a-marker type="pattern" url='./pattern-Hiro_Arthur.patt' minConfidence="0.25" emitevents="true">
                <a-box position="0 0 0" material="opacity: 0; transparent: true; color: blue" scale=".1 .1 .1"></a-box>
                <a-entity
                    id="box"
                    class="interactable"
                    scale="9 9 9"
                    position="0 0 0"
                    animate-on-click=""
                    gltf-model="./Assets/egg_box.glb"
                ></a-entity>
            </a-marker>
            <a-entity camera>
                <a-cursor cursor="rayOrigin: mouse" raycaster="objects: .interactable" fuse="false" material="shader: flat; opacity: 0.8">
                </a-cursor>
                <a-light id="light" type="directional" color="#ffffff" intensity="2" position="0 0 1"></a-light>
            </a-entity>
        </a-scene>

        
        <div id="ui" class="overlay">
            <div id="menu">
                <label>Taille</label>
                <input id="size" type="range" min="1" max="3" step="0.01">
                <span id="sizeValue">1</span>
                <br>
                <label>Couleur</label>
                <input id="color" type="color" value="#ffffff">
            </div>
        </div>


        <script>
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            const marker = document.querySelector('a-marker');
            const ui = document.getElementById('ui');
            ui.style.display = 'none';
            const slider = document.getElementById('size');
            slider.value = 1;
            const box = document.getElementById('box');
            const colorPicker = document.getElementById('color');
            colorPicker.value = '#ffffff';
            const light = document.getElementById('light');

            document.querySelector('a-scene').addEventListener('render-target-loaded', e => {
                const r = e.target.renderer;
                r.physicallyCorrectLights = true;
            });

            marker.addEventListener('markerFound', () => {
                console.log('FOUND');
                ui.style.display = 'block';
            });
            marker.addEventListener('markerLost',  () => {
                console.log('LOST');
                ui.style.display = 'none';
            });
            slider.addEventListener('input', (event) => {
                let scale = event.target.value * 9;
                box.setAttribute('scale', `${scale} ${scale} ${scale}`);
            });
            slider.addEventListener('input', (event) => {
                document.getElementById('sizeValue').innerText = event.target.value;
            });
            colorPicker.addEventListener('input', (event) => {
                let color = event.target.value;
                light.setAttribute('color', color);
            });
            AFRAME.registerComponent('animate-on-click', {

                init: function () {
                var el = this.el;
                var state = false;
                var finished = true;

                el.addEventListener('click', async function () {
                    if (!state && finished) {
                        el.setAttribute('animation__rotate', "property: rotation; to: 0 360 0; dur: 1500; easing: linear; loop: true");
                        el.setAttribute('animation__updown', "property: position; dir: alternate; to: 0 .5 0; dur: 1000; easing: easeInOutSine; loop: true");
                        state = !state;
                    } else if (state && finished) {
                        finished = false;
                        var rot = el.getAttribute('rotation').y;
                        if (rot > 180) 
                        { 
                            el.setAttribute('animation__rotate', "property: rotation; to: 0 360 0 ; dur: 500; easing: easeInOutQuad; loop: false");
                            el.setAttribute('animation__updown', "property: position; to: 0 0 0; dur: 500; easing: easeInOutQuad; loop: false");
                            await sleep(500).then(() => {
                                el.setAttribute('animation__rotate', "property: rotation; to: 0 0 0 ; dur: 0; easing: easeInOutQuad; loop: false")
                            });
                        } 
                        else 
                        { 
                            el.setAttribute('animation__rotate', "property: rotation; to: 0 0 0 ; dur: 500; easing: easeInOutQuad; loop: false");
                            el.setAttribute('animation__updown', "property: position; to: 0 0 0; dur: 500; easing: easeInOutQuad; loop: false");
                            await sleep(500);
                        }
                        state = !state;
                        finished = true;
                    }
                });
                }
            });
        </script>
        <!--<script>
            AFRAME.registerComponent('hdri-env', {
                schema: { src: { type: 'asset' } }, // ex: url(./Assets/overcast.exr)
                init() {
                    const sceneEl = this.el.sceneEl;
                    const src = this.data.src;

                    const apply = () => {
                    const pmrem = new THREE.PMREMGenerator(sceneEl.renderer);

                    // 1) Essaye EXR
                    new THREE.EXRLoader()
                        .setDataType(THREE.HalfFloatType) // plus compatible mobile
                        .load(src, (tex) => {
                        const env = pmrem.fromEquirectangular(tex).texture;
                        sceneEl.object3D.environment = env; // ne PAS setter background en AR
                        tex.dispose();
                        console.log('[HDRI] EXR ok:', src);
                        }, undefined, () => {
                        console.warn('[HDRI] EXR échec → fallback HDR');
                        // 2) Fallback HDR (même nom, extension .hdr)
                        const hdr = src.replace(/\.(exr)$/i, '.hdr');
                        new THREE.RGBELoader()
                            .setDataType(THREE.UnsignedByteType)
                            .load(hdr, (tex) => {
                            const env = pmrem.fromEquirectangular(tex).texture;
                            sceneEl.object3D.environment = env;
                            console.log('[HDRI] RGBE ok:', hdr);
                            }, undefined, () => {
                            console.warn('[HDRI] HDR échec → fallback LDR');
                            // 3) Fallback LDR (jpg/png)
                            const ldr = src.replace(/\.(exr|hdr)$/i, '.jpg');
                            new THREE.TextureLoader().load(ldr, (tex) => {
                                tex.colorSpace = THREE.SRGBColorSpace;
                                const env = pmrem.fromEquirectangular(tex).texture;
                                sceneEl.object3D.environment = env;
                                console.log('[HDRI] LDR ok:', ldr);
                            }, undefined, (e) => console.error('[HDRI] LDR échec', e));
                            });
                        });
                    };

                    if (sceneEl.renderer) apply();
                    else sceneEl.addEventListener('render-target-loaded', apply);
                }
                });
        </script>-->
  </body>
</html>